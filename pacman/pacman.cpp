#include "stdafx.h"
#include "vector"
#include "windows.h"
#include "stdio.h"
#include "conio.h"
#include "thread"
#include "mutex" 

#define TRUE 1;
#define FALSE 0;
#define PACMAN_CHAR 2
#define BOT_CHAR 1
#define WALL_CHAR 219
#define DOT_CHAR 46
#define BANK_CHAR 0
#define DIRECTION_UP 'w'
#define DIRECTION_DOWN 's'
#define DIRECTION_LEFT 'a'
#define DIRECTION_RIGHT 'd'
#define MAXBOT 1
#define MAXROWS 32
#define MAXCOLUMNS 28
#define INCREASE_SCORE 10

struct charactor
{
	char direction = 0;
	int x = 0;
	int y = 15;
};

using namespace std;
int score = 0;
HANDLE  hConsole;
COORD coord;
std::mutex mtx;
charactor pacman;
bool gameOver = false;
bool gameWin = false;

char arrDirection[] = { (char)DIRECTION_UP, (char)DIRECTION_DOWN, (char)DIRECTION_LEFT, (char)DIRECTION_RIGHT };

char levelMatrix[MAXROWS][MAXCOLUMNS] = {
	{ WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR },
	{ WALL_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, WALL_CHAR },
	{ WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR },
	{ WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR },
	{ WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR },
	{ WALL_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, WALL_CHAR },
	{ WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR },
	{ WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR },
	{ WALL_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, WALL_CHAR },
	{ WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, BANK_CHAR, WALL_CHAR, WALL_CHAR, BANK_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR },
	{ WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, BANK_CHAR, WALL_CHAR, WALL_CHAR, BANK_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR },
	{ WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR },
	{ WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, BANK_CHAR, WALL_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, WALL_CHAR, BANK_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR },
	{ WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, BANK_CHAR, WALL_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, WALL_CHAR, BANK_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR },
	{ WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, BANK_CHAR, WALL_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, WALL_CHAR, BANK_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR },
	{ 074, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, DOT_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, WALL_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, WALL_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, DOT_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR },
	{ WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, BANK_CHAR, WALL_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, WALL_CHAR, BANK_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR },
	{ WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, BANK_CHAR, WALL_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, WALL_CHAR, BANK_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR },
	{ WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, BANK_CHAR, WALL_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, WALL_CHAR, BANK_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR },
	{ WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, BANK_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR },
	{ WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, BANK_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, BANK_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR },
	{ WALL_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, WALL_CHAR },
	{ WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR },
	{ WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR },
	{ WALL_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, WALL_CHAR },
	{ WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR },
	{ WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR },
	{ WALL_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, WALL_CHAR },
	{ WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR },
	{ WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, DOT_CHAR, WALL_CHAR },
	{ WALL_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, DOT_CHAR, WALL_CHAR },
	{ WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR, WALL_CHAR }
};



void gotoxy(int x, int y) {
	hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
	coord.X = x;
	coord.Y = y;
	SetConsoleCursorPosition(hConsole, coord);
}

void printxy(int x, int y, char ch) {
	gotoxy(x, y + 1);
	printf("%c", ch);
	gotoxy(0, 0);
}

void show_map() {
	printf("Score : %d\n", score);
	for (int y = 0; y < 32; y++) {
		for (int x = 0; x < 28; x++) {
			printf("%c", levelMatrix[y][x]);
		}
		printf("\n");
	}
}

void addScore(int x, int y) {
	if (levelMatrix[y][x] == DOT_CHAR) {
		score += INCREASE_SCORE;
	}
}

void pacmanMove(int old_x, int old_y, int new_x, int new_y){
	if (levelMatrix[new_y][new_x] != (char)WALL_CHAR){
		addScore(new_x, new_y);
		levelMatrix[old_y][old_x] = BANK_CHAR;
		levelMatrix[new_y][new_x] = PACMAN_CHAR;
		printxy(old_x, old_y, BANK_CHAR);
		printxy(new_x, new_y, PACMAN_CHAR);
		pacman.x = new_x;
		pacman.y = new_y;
	}
}

bool pacmanWalk(){
	int tmpX = pacman.x;
	int tmpY = pacman.y;
	switch (pacman.direction)
	{
	case DIRECTION_UP:
		tmpY = tmpY - 1 < 0 ? MAXROWS - 1 : tmpY - 1;
		break;
	case DIRECTION_DOWN:
		tmpY = (tmpY +1) % MAXROWS;
		break;
	case DIRECTION_LEFT:
		tmpX = tmpX - 1 < 0 ? MAXCOLUMNS - 1 : tmpX - 1;
		break;
	case DIRECTION_RIGHT:
		tmpX = (tmpX + 1) % MAXROWS;
		break;
	default:
		return false;
	}
	pacmanMove(pacman.x, pacman.y, tmpX, tmpY);
	if (score>=(248*INCREASE_SCORE))
	{
		return true;
	}
	else{
		return false;
	}
}

void botMove(charactor &botIn, int new_x, int new_y){
	printxy(botIn.x, botIn.y, levelMatrix[botIn.y][botIn.x]);
	printxy(new_x, new_y, BOT_CHAR);
	botIn.x = new_x;
	botIn.y = new_y;
}

bool navigat(charactor &botIn, int &new_x, int &new_y){
	int tmpX = botIn.x;
	int tmpY = botIn.y;
	switch (botIn.direction)
	{
	case DIRECTION_UP:
		tmpY = tmpY - 1 < 0 ? MAXROWS - 1 : tmpY - 1;
		break;
	case DIRECTION_DOWN:
		tmpY = (tmpY + 1) % MAXROWS;
		break;
	case DIRECTION_LEFT:
		tmpX = tmpX - 1 < 0 ? MAXCOLUMNS - 1 : tmpX - 1;
		break;
	case DIRECTION_RIGHT:
		tmpX = (tmpX + 1) % MAXROWS;
		break;
	default:
		break;
	}
	if (levelMatrix[tmpY][tmpX] != (char)WALL_CHAR){
		new_x = tmpX;
		new_y = tmpY;
		return true;
	}
	else{
		return false;
	}
}

bool botWalk(charactor &botIn){
	int tmpX = 0;
	int tmpY = 0;

	if (navigat(botIn, tmpX, tmpY) == false){
		while (true){
			int ran = rand() % 4;
			botIn.direction = arrDirection[ran] != botIn.direction ? arrDirection[ran] : arrDirection[(ran + 1) % 4];
			if (navigat(botIn, tmpX, tmpY) == true){
				break;
			}
		}
	}

	if (levelMatrix[botIn.y][botIn.x] == (char)PACMAN_CHAR){
		return true;
	}
	else if (levelMatrix[tmpY][tmpX] == (char)PACMAN_CHAR){
		botMove(botIn, tmpX, tmpY);
		return true;
	}
	else{
		botMove(botIn, tmpX, tmpY);
		return false;
	}

}

void readKey() {
	while (true) {
		char directionInput = _getch();
		if (gameWin == true || gameOver == true) break;
		mtx.lock();
		int tmpX = pacman.x;
		int tmpY = pacman.y;
		switch (directionInput)
		{
		case DIRECTION_UP:
			tmpY = tmpY - 1 < 0 ? MAXROWS - 1 : tmpY - 1;
			break;
		case DIRECTION_DOWN:
			tmpY = (tmpY + 1) % MAXROWS;
			break;
		case DIRECTION_LEFT:
			tmpX = tmpX - 1 < 0 ? MAXCOLUMNS - 1 : tmpX - 1;
			break;
		case DIRECTION_RIGHT:
			tmpX = (tmpX + 1) % MAXROWS;
			break;
		default:
			return;
		}
		pacman.direction = levelMatrix[tmpY][tmpX] != (char)WALL_CHAR ? directionInput : pacman.direction;
		mtx.unlock();
	}

}

void main() {
	printf(":::PACMAN:::\n");
	printf("Please enter to start game.");
	_getch();

	system("cls");
	std::thread first(readKey);
	show_map();
	gotoxy(0,33);
	printf("w : Up     s: Down\n");
	printf("a : Left   d: Right\n");
	pacman.direction = (char)DIRECTION_RIGHT;
	int maxBot = 4;
	charactor bot[4];
	for (int i = 0; i < maxBot;i++){
		bot[i].direction = arrDirection[i%4];
		bot[i].x = 13;
		bot[i].y = 15;
	}

	while (true) {
		Sleep(500);
		gameWin = pacmanWalk();
		gotoxy(0, 0);
		printf("                                           ");
		gotoxy(0, 0);
		printf("Score: %d", score);
		
		for (int i = 0; i < maxBot; i++){
			gameOver = botWalk(bot[i]);
			if (gameOver == true)
			{
				break;
			}
		}

		if (gameOver == true || gameWin == true) break;
	}

	if (gameOver == true)
	{
		gotoxy(0, 0);
		printf("GAMEOVER!! Score: %d", score);
	}
	else if (gameWin == true){
		printf("You Win!! Score: %d", score);
	}

	first.join();
	while (true){
		_getch();
	}
}

